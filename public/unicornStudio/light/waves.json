{
  "history": [
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "gradient",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform float uTime;\nuniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0.8156862745098039, 0.8352941176470589, 1);\ncase 1: return vec3(0.8274509803921568, 0.8549019607843137, 1);\ncase 2: return vec3(0.9294117647058824, 0.9411764705882353, 1);\ncase 3: return vec3(1, 1, 1);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0437;\ncase 1: return 0.3000;\ncase 2: return 0.6531;\ncase 3: return 1.0000;\ncase 4: return 0.0000;\ncase 5: return 0.0000;\ncase 6: return 0.0000;\ncase 7: return 0.0000;\ncase 8: return 0.0000;\ncase 9: return 0.0000;\ncase 10: return 0.0000;\ncase 11: return 0.0000;\ncase 12: return 0.0000;\ncase 13: return 0.0000;\ncase 14: return 0.0000;\ncase 15: return 0.0000;\ndefault: return 0.0;\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}float rand(vec2 co) {\nreturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}vec3 linear_from_srgb(vec3 rgb) {\nreturn pow(rgb, vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin) {\nreturn pow(lin, vec3(1.0/2.2));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);\nvec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) );\nvec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) );\nvec3 lms = mix( lms1, lms2, a );\nlms *= 1.0 + 0.025 * a * (1.0-a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nfor (int i = 0; i < 4 - 1; i++) {\nfloat colorPosition = getStop(i);\nfloat nextColorPosition = getStop(i + 1);\nif (position <= nextColorPosition) {\nfloat mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition);\nvec3 linStart = linear_from_srgb(getColor(i));\nvec3 linEnd = linear_from_srgb(getColor(i + 1));\nvec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor);\nreturn srgb_from_linear(mixedLin);\n}\n}\nreturn getColor(4 - 1);\n}out vec4 fragColor;vec3 applyColorToPosition(float position) {\nvec3 color = vec3(0);\nposition -= (uTime * 0.01 + 0.0000);\nfloat cycle = floor(position);\nbool reverse = 1.0000 > 0.5 && int(cycle) % 2 == 0;\nfloat animatedPos = reverse ? 1.0 - fract(position) : fract(position);color = getGradientColor(animatedPos);\nfloat dither = rand(gl_FragCoord.xy) * 0.005;\ncolor += dither;\nreturn color;\n}vec3 linearGrad(vec2 uv) {\nfloat position = (uv.x+0.5);\nreturn applyColorToPosition(position);\n}vec3 getGradient(vec2 uv) {\nreturn linearGrad(uv);\n}vec3 getColor(vec2 uv) {return getGradient(uv);return vec3(0.8156862745098039, 0.8352941176470589, 1);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.5000*2.);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": true },
      "id": "effect"
    },
    {
      "breakpoints": [
        {
          "max": null,
          "min": 992,
          "name": "Desktop",
          "props": {
            "width": 0.49660178547135064,
            "top": 0.7041021014201092,
            "left": 0.21335087747925513,
            "height": 0.21259941924015685
          }
        },
        {
          "min": 0,
          "props": {
            "left": 0.38991666666666663,
            "width": 1.159238705738706,
            "top": 0.7564337799693337,
            "height": 0.4962798822135489
          },
          "max": 575,
          "name": "Mobile"
        }
      ],
      "visible": true,
      "locked": true,
      "aspectRatio": 1.0793650793650795,
      "layerName": "",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 0.82,
      "effects": [],
      "displace": 0,
      "trackMouse": 0,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "SCREEN",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": { "appear": [], "scroll": [], "hover": [] },
      "layerType": "shape",
      "width": 0.49660178547135064,
      "widthMode": "relative",
      "height": 0.7361391172869431,
      "heightMode": "auto",
      "left": 0.21335087747925513,
      "leftMode": "relative",
      "top": 0.7041021014201092,
      "topMode": "relative",
      "rotation": 0,
      "trackAxes": "xy",
      "borderRadius": 0,
      "gradientAngle": 0,
      "strokeWidth": 0,
      "coords": [
        [0, 0],
        [0.49660178547135064, 0],
        [0.49660178547135064, 0.7361391172869431],
        [0, 0.7361391172869431]
      ],
      "fill": ["#000000"],
      "fitToCanvas": false,
      "gradientType": "linear",
      "type": "circle",
      "stroke": ["#000000"],
      "numSides": 3,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;\nuniform sampler2D uTexture;\nuniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 1. - (1. - src) * (1. - dst);\n}const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\nvec3 unpremultColor = color.rgb / max(color.a, 0.0001);\nvec3 blendedColor = blend(4, unpremultColor, background.rgb);\ncolor = vec4(blendedColor, 1.0) * (color.a * 0.8200);\ncolor = color + background * (1.0 - color.a);\nreturn color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0);\nif(uSampleBg == 1) {\nbackground = texture(uBgTexture, vTextureCoord);\n}\nvec4 color = texture(uTexture, uv);vec4 col = getOutputByMode(color, background);fragColor = col;\n}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
      ],
      "data": { "uniforms": {} },
      "id": "shape"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "blur",
      "usesPingPong": false,
      "trackMouse": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.49931874120956404, 0.6111111111111112) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 0 <= 1 ? 6. : 11.;\nfloat amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 0 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}",
        "#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.49931874120956404, 0.6111111111111112) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 1 <= 1 ? 6. : 11.;\nfloat amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 1 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}",
        "#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.49931874120956404, 0.6111111111111112) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 2 <= 1 ? 6. : 11.;\nfloat amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 2 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}",
        "#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.49931874120956404, 0.6111111111111112) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 3 <= 1 ? 6. : 11.;\nfloat amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 3 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither;\nfragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
      ],
      "data": {
        "downSample": 0.25,
        "depth": false,
        "uniforms": {},
        "isBackground": false,
        "passes": [
          { "prop": "vertical", "value": 1, "downSample": 0.25 },
          { "prop": "vertical", "value": 2, "downSample": 0.5 },
          { "prop": "vertical", "value": 3, "downSample": 0.5 }
        ]
      },
      "id": "effect1"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "sdf_shape",
      "usesPingPong": false,
      "texture": false,
      "speed": 0.05,
      "trackMouseMove": 0,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "trackMouse": 0,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nuniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.141592653;\nconst float PI2 = 6.283185306;\nconst int DISP_STEPS = 12;\nconst vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize;\nfloat customTexAspect;const mat3 ROT_Y_90 = mat3(\n0.0, 0.0, 1.0,\n0.0, 1.0, 0.0,\n-1.0, 0.0, 0.0\n);const mat3 ROT_Z_90 = mat3(\n0.0, -1.0, 0.0,\n1.0, 0.0, 0.0,\n0.0, 0.0, 1.0\n);const mat3 ROT_X_90 = mat3(\n1.0, 0.0, 0.0,\n0.0, 0.0, -1.0,\n0.0, 1.0, 0.0\n);mat3 rotY(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}mat3 rotX(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}mat3 rotZ(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}mat2 rot(float a) {\nfloat s = sin(a);\nfloat c = cos(a);\nreturn mat2(c, -s, s, c);\n}vec3 twistY(vec3 p, float amount) {\nfloat c = cos(amount * p.y);\nfloat s = sin(amount * p.y);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(m * p.xz, p.y);\n}vec3 twistX(vec3 p, float amount) {\nfloat c = cos(amount * p.x);\nfloat s = sin(amount * p.x);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(p.x, m * p.yz);\n}float smin(float a, float b, float k) {\nfloat h = max(k - abs(a - b), 0.0);\nreturn min(a, b) - h * h * 0.25 / k;\n}float sphere(vec3 p, float r) {\nreturn length(p) - r;\n}float sdfCylinder(vec3 p, float radius, float height) {\nvec2 d = abs(vec2(length(p.xz) - radius, p.y)) - vec2(radius, height * 0.5);\nreturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}float sdStar5(vec2 p, float r, float rf)\n{\nconst vec2 k1 = vec2(0.809016994375, -0.587785252292);\nconst vec2 k2 = vec2(-k1.x,k1.y);\np.x = abs(p.x);\np -= 2.0*max(dot(k1,p),0.0)*k1;\np -= 2.0*max(dot(k2,p),0.0)*k2;\np.x = abs(p.x);\np.y -= r;\nvec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\nfloat h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\nreturn length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}float mergedDiscs(vec3 p) {\nfloat result = sdfCylinder(p, 0.7, 0.01 + 1.0000 * 0.5);for(float i = 1.; i < 4.; i++) {\nfloat angle = (i * 45.)/360. * 2.0 * PI;\nmat2 rotZMat = rot(angle);\nvec3 rotatedP = vec3(rotZMat * p.xy, p.z);result = smin(\nresult,\nsdfCylinder(rotatedP, 0.7, 0.01 + 1.0000 * 0.5),\n0.2\n);\n}return max(result, sphere(p, 1.4));\n}vec3 getRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getThreeDRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getAdjustedP(vec3 p) {\nfloat scale = max(1.3380, 0.000000001);\nfloat scaleFactor = 1.0/scale;\nvec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 1.24);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.0000 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000);\nvec2 axis = vec2(-1. * vec3(0.2713858374191739, 0.4540604884327648, -0.0702).y - 1. + mousePos.y/PI, vec3(0.2713858374191739, 0.4540604884327648, -0.0702).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02;\nfloat timeX = vec3(0, 1, 0).x * baseTime;\nfloat timeY = vec3(0, 1, 0).y * baseTime;\nfloat timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI);\nmat3 rotXMat = rotX(axis.x * PI);\nmat3 rotZMat = rotZ(vec3(0.2713858374191739, 0.4540604884327648, -0.0702).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat;\nmat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP;\nadjustedP = combinedAnimation * adjustedP;\nadjustedP = getThreeDRepeat(adjustedP);\nadjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y)));\nadjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP;\n}float getMergedSDF(vec3 p) {\np = getAdjustedP(p);\nreturn mergedDiscs(p);\n}float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {\nfloat NdotV = abs(dot(eyeVector, worldNormal));\nfloat width = fwidth(dot(eyeVector, worldNormal));\nfloat threshold = 0.2;\nfloat edgeDampFactor = smoothstep(threshold, -threshold, width);\nfloat fresnelFactor = 1.0 - NdotV;\nreturn pow(fresnelFactor, power) * mix(1., edgeDampFactor * 2., 0.5);\n}vec3 noFrostOrDispersion(vec3 rd, vec3 normal) {\nfloat ior = 1.0 / (1.0 + 0.5000 * 0.25);\nvec3 refractedRay = refract(rd, normal, ior);\nreturn texture(uTexture, vTextureCoord - refractedRay.xy).rgb;\n}vec3 frostOrDispersion(vec3 rd, vec3 normal) {\nvec3 refractionColor = vec3(0);\nfloat iorBase = 1. + 0.5000 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.2500 * 1.2;for (int i = 0; i < DISP_STEPS; ++i) {\nfloat step = float(i) / float(DISP_STEPS);\nvec3 disp = step * dispCoefficients;\nvec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r);\nvec3 refractedRayG = refract(rd, normal, ior.g);\nvec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r;\nrefractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g;\nrefractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b;\n}return clamp(refractionColor / float(DISP_STEPS), 0.0, 1.0);\n}vec3 calculateNormal(vec3 p, float eps) {\nvec2 e = vec2(1.0, -1.0) * eps * 0.5;\nreturn normalize(\ne.xyy * getMergedSDF(p + e.xyy) +\ne.yyx * getMergedSDF(p + e.yyx) +\ne.yxy * getMergedSDF(p + e.yxy) +\ne.xxx * getMergedSDF(p + e.xxx)\n);\n}vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal);\nreturn noFrostOrDispersion(rd, normal);\n}float scene(vec3 p) {\nreturn max(0.0000000001, getMergedSDF(p) - (0.0000 + 0.005)) * max(1.3380, 0.000000001);\n}const int STEPS = 128;\nconst float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) {\nfloat pixelSize = 0.0025;\nfloat traveled = 0.;\nvec3 entryPoint = vec3(0.0);\nvec3 entryNormal = vec3(0.0);\nfloat partialAlpha = 0.0;\nfloat lastDistance = 0.0;\nfloat smoothing = mix(1., 4., 1.0000);for (int i = 0; i < STEPS; ++i) {\nvec3 currentPos = ro + rd * traveled;\nfloat distance = scene(currentPos);\nfloat progress = float(i)/float(STEPS);\nfloat step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) {\npartialAlpha = 1.;\nentryPoint = currentPos;\nentryNormal = calculateNormal(entryPoint, pixelSize * smoothing);\nbreak;\n}lastDistance = distance;traveled += max(step, pixelSize);\nif (traveled > MAX_DISTANCE) break;\n}if (partialAlpha == 0.0) {\nreturn texture(uTexture, vTextureCoord);\n}vec3 samplePosition = mix(rd, entryPoint, 0.0000);vec3 refractionColor = texture(uTexture, vTextureCoord).rgb;refractionColor = sampleTexture(samplePosition, entryNormal);\nvec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5321095666699623, 0.5849442614770538), vec3(0.25, 0.25, -3).z);\nvec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir);\nvec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.0000);\nvec3 fresnelEffect = vec3(0.0);fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.5000 * vec3(1, 1, 1);vec3 specularEffect = vec3(0.0);vec3 halfwayDir = normalize(lightDir + rd);\nfloat specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.5000 + 0.01);\nspecularEffect = specFactor * 0.5000 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect;\nvec3 finalColor = mix(refractionColor, vec3(1, 1, 1) * lightAndShadow, 0.0000);\nfinalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor;\n}out vec4 fragColor;void main() {\nvec4 col = vec4(0);\nvec4 bg = texture(uTexture, vTextureCoord);if(1.3380 <= 0.0001 || 1.0000 <= 0.0001) {\ncol = vec4(0);\nif(1 == 1) {\ncol = bg;\n}\nfragColor = col;\nreturn;\n}vec2 pos = vec2(0.5321095666699623, 0.5849442614770538) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 uv = vTextureCoord - pos;\nfloat fovFactor = tan(radians(20.) * 0.5);\nvec3 rd = vec3(uv * fovFactor, 0.5);\ncol = rayMarch(viewDir, rd);\nfloat dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0;\ncol += dither;col = mix(bg, col, 1.0000);\nfragColor = col;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect2"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "bokeh",
      "usesPingPong": false,
      "trackMouse": 0.27,
      "trackAxes": "xy",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uBlueNoise;uniform vec2 uMousePos;\nuniform vec2 uResolution;float ease (int easingFunc, float t) {\nreturn t * t * t;\n}const float PI = 3.14159265;\nconst float PI2 = 6.28318530718;\nconst int SAMPLES = 128;vec2 getDiskSample(int index) {\nswitch(index) {\ncase 0: return vec2(0, 0);\ncase 1: return vec2(0.7062550187110901, 0.03469608351588249);\ncase 2: return vec2(0.49759235978126526, 0.0490085706114769);\ncase 3: return vec2(0.8566519618034363, 0.1270723193883896);\ncase 4: return vec2(0.34675997495651245, 0.06897484511137009);\ncase 5: return vec2(0.7668770551681519, 0.19209270179271698);\ncase 6: return vec2(0.5860038995742798, 0.17776232957839966);\ncase 7: return vec2(0.880733847618103, 0.31513160467147827);\ncase 8: return vec2(0.2309698760509491, 0.09567085653543472);\ncase 9: return vec2(0.6779919862747192, 0.3206663131713867);\ncase 10: return vec2(0.49300897121429443, 0.2635187804698944);\ncase 11: return vec2(0.7731460928916931, 0.46340593695640564);\ncase 12: return vec2(0.3600369095802307, 0.24056896567344666);\ncase 13: return vec2(0.6659845113754272, 0.4939277768135071);\ncase 14: return vec2(0.5112983584403992, 0.41961172223091125);\ncase 15: return vec2(0.7174228429794312, 0.6502341628074646);\ncase 16: return vec2(0.125, 0.125);\ncase 17: return vec2(0.4894784986972809, 0.5400562882423401);\ncase 18: return vec2(0.336437851190567, 0.40995070338249207);\ncase 19: return vec2(0.5265287756919861, 0.7099418640136719);\ncase 20: return vec2(0.21960841119289398, 0.32866722345352173);\ncase 21: return vec2(0.41647082567214966, 0.694839596748352);\ncase 22: return vec2(0.3004576563835144, 0.5621167421340942);\ncase 23: return vec2(0.40702033042907715, 0.8605721592903137);\ncase 24: return vec2(0.11717239022254944, 0.28287917375564575);\ncase 25: return vec2(0.25959107279777527, 0.725508451461792);\ncase 26: return vec2(0.17019447684288025, 0.5610560178756714);\ncase 27: return vec2(0.2231915444135666, 0.8910306096076965);\ncase 28: return vec2(0.0912451446056366, 0.45872029662132263);\ncase 29: return vec2(0.12439680844545364, 0.8386151790618896);\ncase 30: return vec2(0.06710775196552277, 0.6813564300537109);\ncase 31: return vec2(0.048294905573129654, 0.9830654263496399);\ncase 32: return vec2(7.654042828657299e-18, 0.125);\ncase 33: return vec2(-0.03523404151201248, 0.7172054052352905);\ncase 34: return vec2(-0.05051687732338905, 0.5129064917564392);\ncase 35: return vec2(-0.1283891648054123, 0.8655294179916382);\ncase 36: return vec2(-0.0731588676571846, 0.3677944839000702);\ncase 37: return vec2(-0.19447903335094452, 0.7764038443565369);\ncase 38: return vec2(-0.18142792582511902, 0.598087728023529);\ncase 39: return vec2(-0.3179328143596649, 0.8885627388954163);\ncase 40: return vec2(-0.10696326941251755, 0.2582321763038635);\ncase 41: return vec2(-0.3250895142555237, 0.6873440146446228);\ncase 42: return vec2(-0.27002641558647156, 0.5051838755607605);\ncase 43: return vec2(-0.4678405523300171, 0.7805448174476624);\ncase 44: return vec2(-0.2503921091556549, 0.37473827600479126);\ncase 45: return vec2(-0.4995090663433075, 0.6735100150108337);\ncase 46: return vec2(-0.4270390570163727, 0.5203486084938049);\ncase 47: return vec2(-0.6556304097175598, 0.7233766317367554);\ncase 48: return vec2(-0.1530931144952774, 0.1530931144952774);\ncase 49: return vec2(-0.547940731048584, 0.49662455916404724);\ncase 50: return vec2(-0.4211843013763428, 0.34565702080726624);\ncase 51: return vec2(-0.7170061469078064, 0.5317679643630981);\ncase 52: return vec2(-0.3447090983390808, 0.23032724857330322);\ncase 53: return vec2(-0.7030628323554993, 0.42139965295791626);\ncase 54: return vec2(-0.5728246569633484, 0.3061811625957489);\ncase 55: return vec2(-0.867959201335907, 0.41051411628723145);\ncase 56: return vec2(-0.3055444359779358, 0.12656064331531525);\ncase 57: return vec2(-0.7349926233291626, 0.2629845440387726);\ncase 58: return vec2(-0.5736655592918396, 0.17401954531669617);\ncase 59: return vec2(-0.8992430567741394, 0.22524864971637726);\ncase 60: return vec2(-0.47482064366340637, 0.09444769471883774);\ncase 61: return vec2(-0.8476815819740295, 0.12574167549610138);\ncase 62: return vec2(-0.692619264125824, 0.06821703910827637);\ncase 63: return vec2(-0.9909616708755493, 0.04868282377719879);\ncase 64: return vec2(-0.0883883461356163, 1.0824450754283193e-17);\ncase 65: return vec2(-0.7117512822151184, -0.03496609628200531);\ncase 66: return vec2(-0.5053074359893799, -0.04976843670010567);\ncase 67: return vec2(-0.8611021637916565, -0.12773244082927704);\ncase 68: return vec2(-0.35743197798728943, -0.07109764218330383);\ncase 69: return vec2(-0.7716551423072815, -0.19328954815864563);\ncase 70: return vec2(-0.5920765995979309, -0.17960448563098907);\ncase 71: return vec2(-0.8846569657325745, -0.3165353238582611);\ncase 72: return vec2(-0.2449805587530136, -0.10147427022457123);\ncase 73: return vec2(-0.6826840043067932, -0.3228854835033417);\ncase 74: return vec2(-0.49913355708122253, -0.2667924463748932);\ncase 75: return vec2(-0.7768542766571045, -0.4656285345554352);\ncase 76: return vec2(-0.36746111512184143, -0.2455296814441681);\ncase 77: return vec2(-0.6697578430175781, -0.49672624468803406);\ncase 78: return vec2(-0.5158433318138123, -0.42334166169166565);\ncase 79: return vec2(-0.7204058766365051, -0.6529378294944763);\ncase 80: return vec2(-0.1397542506456375, -0.1397542506456375);\ncase 81: return vec2(-0.4930644631385803, -0.5440127849578857);\ncase 82: return vec2(-0.34107857942581177, -0.41560545563697815);\ncase 83: return vec2(-0.529154896736145, -0.7134827375411987);\ncase 84: return vec2(-0.22503165900707245, -0.33678367733955383);\ncase 85: return vec2(-0.41894248127937317, -0.6989632844924927);\ncase 86: return vec2(-0.3033328950405121, -0.5674959421157837);\ncase 87: return vec2(-0.40877094864845276, -0.8642735481262207);\ncase 88: return vec2(-0.12195689231157303, -0.2944299876689911);\ncase 89: return vec2(-0.26129332184791565, -0.7302659153938293);\ncase 90: return vec2(-0.17211763560771942, -0.567395806312561);\ncase 91: return vec2(-0.22422246634960175, -0.8951462507247925);\ncase 92: return vec2(-0.09286022931337357, -0.46683987975120544);\ncase 93: return vec2(-0.12507104873657227, -0.8431605696678162);\ncase 94: return vec2(-0.06766466796398163, -0.6870108842849731);\ncase 95: return vec2(-0.04848925396800041, -0.9870214462280273);\ncase 96: return vec2(-2.81227478546514e-17, -0.1530931144952774);\ncase 97: return vec2(0.03549996390938759, -0.7226183414459229);\ncase 98: return vec2(0.05125438794493675, -0.5203945636749268);\ncase 99: return vec2(0.12904255092144012, -0.8699342012405396);\ncase 100: return vec2(0.0751635953783989, -0.37787291407585144);\ncase 101: return vec2(0.1956612914800644, -0.7811236381530762);\ncase 102: return vec2(0.18323321640491486, -0.6040389537811279);\ncase 103: return vec2(0.31932422518730164, -0.8924514055252075);\ncase 104: return vec2(0.11218402534723282, -0.27083620429039);\ncase 105: return vec2(0.3272787034511566, -0.6919726729393005);\ncase 106: return vec2(0.27322208881378174, -0.5111625790596008);\ncase 107: return vec2(0.4700421690940857, -0.7842180132865906);\ncase 108: return vec2(0.25516191124916077, -0.38187679648399353);\ncase 109: return vec2(0.5022764205932617, -0.6772413849830627);\ncase 110: return vec2(0.43070468306541443, -0.5248152017593384);\ncase 111: return vec2(0.6583119034767151, -0.7263352870941162);\ncase 112: return vec2(0.16535945236682892, -0.16535945236682892);\ncase 113: return vec2(0.5518407225608826, -0.5001592636108398);\ncase 114: return vec2(0.4266902208328247, -0.3501756191253662);\ncase 115: return vec2(0.720512330532074, -0.5343683362007141);\ncase 116: return vec2(0.35245633125305176, -0.23550379276275635);\ncase 117: return vec2(0.7071385979652405, -0.42384254932403564);\ncase 118: return vec2(0.5781042575836182, -0.30900317430496216);\ncase 119: return vec2(0.8716292381286621, -0.41224992275238037);\ncase 120: return vec2(0.31626853346824646, -0.13100272417068481);\ncase 121: return vec2(0.7396891117095947, -0.26466497778892517);\ncase 122: return vec2(0.5798675417900085, -0.1759008914232254);\ncase 123: return vec2(0.9033212661743164, -0.22627019882202148);\ncase 124: return vec2(0.4826694428920746, -0.09600891917943954);\ncase 125: return vec2(0.8521785736083984, -0.12640875577926636);\ncase 126: return vec2(0.6981825828552246, -0.06876497715711594);\ncase 127: return vec2(0.9948862791061401, -0.04887562617659569);\ndefault: return vec2(0.0);\n}\n}float getBlueNoiseOffset(vec2 st) {\nivec2 texSize = ivec2(512, 512);\nvec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0);\nreturn mod((blueNoise.r - 0.5) * PI2, PI2);\n}vec4 bokehBlur(vec2 uv, float blurRadius, float intensity) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec3 accumulatedColor = vec3(0.0);\nvec3 accumulatedWeights = vec3(0.0);\nvec2 pixelSize = vec2(1.0 / aspectRatio, 1.0) * blurRadius * 0.075;\nfloat accumulatedAlpha = 0.;\nfloat noiseOffset = (getBlueNoiseOffset(uv) - 0.5) * 0.1;\nfloat noiseAngle = noiseOffset * PI2;\nmat2 rotationMatrix = mat2(\ncos(noiseAngle), -sin(noiseAngle),\nsin(noiseAngle), cos(noiseAngle)\n);for (int i = 0; i < 128; i++) {\nvec2 sampleOffset = rotationMatrix * getDiskSample(i) * pixelSize;\nfloat jitterAmount = 0.05 * (sin(float(i) * 0.1) * 0.5 + 0.5);\nsampleOffset *= 1.0 + jitterAmount * sin(float(i) * 0.7 + noiseOffset);\nvec4 colorSample = texture(uTexture, uv + sampleOffset);\nvec3 bokehWeight = vec3(5.0) + pow(colorSample.rgb, vec3(9.0)) * intensity;\naccumulatedAlpha += colorSample.a;accumulatedColor += colorSample.rgb * bokehWeight;\naccumulatedWeights += bokehWeight;\n}return vec4(accumulatedColor / accumulatedWeights, accumulatedAlpha / 128.0);\n}out vec4 fragColor;vec4 blurPass(vec2 uv) {\nvec2 pos = vec2(0.7508519138357933, 0.27803566683590597) + mix(vec2(0), (uMousePos-0.5), 0.2700);\nfloat dis = distance(uv, pos) * 1000.;\nfloat tilt = mix(1.-dis * 0.001 , dis * 0.001, 0.1600);\nreturn bokehBlur(uv, 0.3700 * ease(4, tilt), 150.0);\n}vec4 getColor(vec2 uv) {\nreturn blurPass(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);if(0.3700 == 0.) {\ncolor = texture(uTexture, uv);\nfragColor = color;return;\n}\ncolor = getColor(uv);\nfragColor = color;}",
        "#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform sampler2D uBlueNoise;uniform vec2 uMousePos;\nuniform vec2 uResolution;float ease (int easingFunc, float t) {\nreturn t * t * t;\n}const float PI = 3.14159265;\nconst float PI2 = 6.28318530718;\nconst int SAMPLES = 128;float getBlueNoiseOffset(vec2 st) {\nivec2 texSize = ivec2(512, 512);\nvec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0);\nreturn mod((blueNoise.r - 0.5) * PI2, PI2);\n}out vec4 fragColor;vec4 composite(vec2 uv) {\nvec4 color = vec4(0.);\nvec2 pos = vec2(0.7508519138357933, 0.27803566683590597) + mix(vec2(0), (uMousePos-0.5), 0.2700);\nfloat dis = distance(uv, pos) * 1000.;\nfloat tilt = mix(1.-dis * 0.001 , dis * 0.001, 0.1600);\nfloat strength = ease(4, tilt);\nvec4 bg = texture(uBgTexture, uv);if(0.3700 <= 0.001) {\nreturn bg;\n}if(strength <= 0.002) {\nreturn bg;\n}\nfloat blueNoiseOffset = getBlueNoiseOffset(uv);\nfloat blueNoiseStrength = 0.005 * 0.3700 * strength;\nvec2 offset = vec2(cos(blueNoiseOffset), sin(blueNoiseOffset)) * min(blueNoiseStrength, 0.01);\nreturn texture(uTexture, uv + offset);\n}vec4 getColor(vec2 uv) {\nreturn composite(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);if(0.3700 == 0.) {\ncolor = texture(uTexture, uv);\nfragColor = color;return;\n}\ncolor = getColor(uv);\nfragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
      ],
      "data": {
        "downSample": 0.5,
        "depth": false,
        "uniforms": {},
        "isBackground": false,
        "passes": [{ "prop": "pass", "value": 1, "includeBg": true }],
        "texture": {
          "src": "https://assets.unicorn.studio/media/blue_noise_med.png",
          "sampler": "uBlueNoise"
        }
      },
      "id": "effect3"
    }
  ],
  "options": {
    "name": "white shape",
    "fps": 60,
    "dpi": 1.5,
    "scale": 1,
    "includeLogo": false,
    "isProduction": false,
    "freePlan": false
  },
  "version": "1.5.2",
  "id": "ZkUXtiCvLgOjVyzBKaI6"
}
